/**
 * 活动周类型判断工具
 * 
 * 活动周期规则：
 * - 每周五 12:00 开始，到下周五 00:00 结束
 * - 循环顺序：黑市周 → 招募周 → 宝箱周 → 黑市周...
 * 
 * 基准点：2025-11-21 12:00:00（黑市周开始）
 * 
 * 长期计算准确性：
 * - ✅ 可以无限循环下去（在JavaScript安全整数范围内，约285616年）
 * - ✅ 1年后、10年后、100年后计算都完全准确
 * - ✅ 只使用纯数学计算，不依赖任何外部数据
 * - ✅ 模运算的特性保证了循环的准确性
 */

/**
 * 活动类型枚举
 */
const 活动类型 = {
  0: '黑市周',
  1: '招募周',
  2: '宝箱周'
};

/**
 * 基准点：已知的黑市周开始时间（2025-11-21 12:00:00）
 * 这个时间是固定的，不会改变
 * 
 * 时间戳精度说明：
 * - JavaScript Number类型可以安全表示的最大整数：9007199254740991（约2^53-1）
 * - 基准时间戳：约1732147200000毫秒
 * - 可以安全计算的时间范围：约285616年（从1970年开始）
 * - 结论：可以安全计算到约2287年，完全满足实际需求
 */
const 基准时间 = new Date('2025-11-21 12:00:00').getTime();

/**
 * 计算指定时间所在的"活动周"开始时间（周五12:00）
 * @param {Date} now - 当前时间
 * @returns {number} 活动周开始时间的时间戳（毫秒）
 */
function 计算活动周开始时间(now) {
  const 当前时间 = new Date(now);
  const 今天周几 = 当前时间.getDay(); // 0=周日, 1=周一, ..., 5=周五, 6=周六
  const 当前小时 = 当前时间.getHours();
  
  // 先计算本周五12:00的时间
  const 本周五12点 = new Date(当前时间);
  
  // 计算距离本周五的天数
  let 距离本周五天数 = 0;
  if (今天周几 < 5) {
    // 周一到周四：距离本周五
    距离本周五天数 = 5 - 今天周几;
  } else if (今天周几 === 5) {
    // 周五：距离本周五0天
    距离本周五天数 = 0;
  } else {
    // 周六、周日：距离下周五（但我们要先算本周五）
    距离本周五天数 = 5 - 今天周几 + 7;
  }
  
  本周五12点.setDate(当前时间.getDate() + 距离本周五天数);
  本周五12点.setHours(12, 0, 0, 0);
  本周五12点.setMinutes(0, 0, 0);
  本周五12点.setSeconds(0, 0);
  本周五12点.setMilliseconds(0);
  
  // 如果当前时间还没到本周五12:00，使用上周五12:00
  if (当前时间.getTime() < 本周五12点.getTime()) {
    本周五12点.setDate(本周五12点.getDate() - 7);
  }
  
  return 本周五12点.getTime();
}

/**
 * 获取当前活动周类型
 * @param {Date} [now] - 可选：指定时间，默认使用当前时间
 * @returns {string} '黑市周' | '招募周' | '宝箱周'
 * 
 * 计算原理：
 * 1. 计算当前时间所在的活动周开始时间（周五12:00）
 * 2. 计算距离基准点有多少个周期（每个周期7天）
 * 3. 使用模运算（% 3）判断类型，因为循环是3周一个周期
 * 
 * 长期准确性保证：
 * - 只使用纯数学计算（减法、除法、模运算）
 * - 不依赖任何外部数据或状态
 * - 模运算的特性保证了循环的准确性
 * - JavaScript的Number类型可以安全表示约285616年的时间范围
 */
export function 获取当前活动周类型(now = new Date()) {
  // 获取当前时间所在的活动周开始时间（周五12:00）
  const 当前活动周开始时间 = 计算活动周开始时间(now);
  
  // 计算距离基准点有多少个周期（每个周期7天）
  // 使用 Math.floor 确保向下取整，避免精度问题
  const 周期数 = Math.floor((当前活动周开始时间 - 基准时间) / (7 * 24 * 60 * 60 * 1000));
  
  // 基准点是黑市周（索引0），所以直接模3
  // 模运算的特性：无论周期数多大，结果都在 0-2 之间，保证循环
  const 活动索引 = 周期数 % 3;
  
  // 处理负数情况（理论上不应该发生，因为基准时间是固定的过去时间点）
  // 但为了代码健壮性，还是加上保护
  const 最终索引 = 活动索引 >= 0 ? 活动索引 : (活动索引 + 3) % 3;
  
  return 活动类型[最终索引];
}

/**
 * 获取当前活动周的开始时间
 * @param {Date} [now] - 可选：指定时间，默认使用当前时间
 * @returns {Date} 活动周开始时间（周五12:00）
 */
export function 获取当前活动周开始时间(now = new Date()) {
  const 时间戳 = 计算活动周开始时间(now);
  return new Date(时间戳);
}

/**
 * 获取当前活动周的结束时间
 * @param {Date} [now] - 可选：指定时间，默认使用当前时间
 * @returns {Date} 活动周结束时间（下周五00:00）
 */
export function 获取当前活动周结束时间(now = new Date()) {
  const 开始时间 = 获取当前活动周开始时间(now);
  const 结束时间 = new Date(开始时间);
  结束时间.setDate(开始时间.getDate() + 7); // 下周五
  结束时间.setHours(0, 0, 0, 0); // 00:00
  return 结束时间;
}

/**
 * 判断指定时间是否在活动周内
 * @param {Date} [time] - 可选：指定时间，默认使用当前时间
 * @returns {boolean} 是否在活动周内
 */
export function 是否在活动周内(time = new Date()) {
  const 开始时间 = 获取当前活动周开始时间(time);
  const 结束时间 = 获取当前活动周结束时间(time);
  const 当前时间 = time.getTime();
  
  return 当前时间 >= 开始时间.getTime() && 当前时间 < 结束时间.getTime();
}

/**
 * 获取下一个活动周类型
 * @param {Date} [now] - 可选：指定时间，默认使用当前时间
 * @returns {string} 下一个活动周类型
 */
export function 获取下一个活动周类型(now = new Date()) {
  const 当前类型 = 获取当前活动周类型(now);
  const 类型索引 = { '黑市周': 0, '招募周': 1, '宝箱周': 2 };
  const 当前索引 = 类型索引[当前类型];
  const 下一个索引 = (当前索引 + 1) % 3;
  
  return 活动类型[下一个索引];
}

/**
 * 获取上一个活动周类型
 * @param {Date} [now] - 可选：指定时间，默认使用当前时间
 * @returns {string} 上一个活动周类型
 */
export function 获取上一个活动周类型(now = new Date()) {
  const 当前类型 = 获取当前活动周类型(now);
  const 类型索引 = { '黑市周': 0, '招募周': 1, '宝箱周': 2 };
  const 当前索引 = 类型索引[当前类型];
  const 上一个索引 = (当前索引 - 1 + 3) % 3;
  
  return 活动类型[上一个索引];
}
